name: ci-cd

on:
  push:
    branches: [ "deploy" ]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  DOCKER_BUILDKIT: 1

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      # JDK + Gradle 캐시
      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Setup Gradle (cache)
        uses: gradle/actions/setup-gradle@v3

      - name: Grant execute permission for Gradle
        run: chmod +x ./gradlew

      # (선택) 배포 타깃 모듈 지정: 예) api, app 등
      # env:
      #   APP_MODULE: api

      # 1) JAR 생성 보장: bootJar 우선, 없으면 jar로 폴백
      - name: Build artifact (bootJar first, then jar)
        run: |
          set -euo pipefail
          PREFIX=""
          if [ -n "${APP_MODULE:-}" ]; then
            PREFIX=":${APP_MODULE}"
            echo "[INFO] Target module: ${APP_MODULE}"
          else
            echo "[INFO] Target module: (root project)"
          fi

          echo "[INFO] Try bootJar"
          if ./gradlew ${PREFIX}:clean ${PREFIX}:bootJar -x test --no-daemon; then
            echo "[INFO] bootJar built"
          else
            echo "[WARN] bootJar not available, fallback to jar"
            ./gradlew ${PREFIX}:clean ${PREFIX}:jar -x test --no-daemon
          fi

      # 2) 산출물(JAR) 자동 탐색(멀티모듈 포함), *-plain.jar 제외
      - name: Locate artifact
        run: |
          set -euo pipefail
          echo "[DEBUG] find artifacts under **/build/libs"
          ls -al **/build/libs || true
          ARTIFACT=$(find . -type f -path "*/build/libs/*.jar" ! -name "*-plain.jar" -print0 \
                     | xargs -0 ls -1S 2>/dev/null | head -n 1 || true)
          if [ -z "$ARTIFACT" ]; then
            echo "No JAR found under **/build/libs"
            echo "HINT: 멀티모듈이면 env.APP_MODULE 로 모듈 지정"
            exit 1
          fi
          echo "ARTIFACT=$ARTIFACT" >> $GITHUB_ENV
          echo "Using artifact: $ARTIFACT"

      # 3) 이미지 이름 소문자화
      - name: Compute image name (lowercase)
        run: echo "IMAGE_NAME=ghcr.io/${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

      - name: Show image name
        run: echo "Image will be pushed as $IMAGE_NAME"

      # 4) GHCR 로그인
      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 5) 태그 계산
      - name: Compute tags
        id: tag
        run: |
          echo "SHORT_SHA=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          echo "TAGS=${IMAGE_NAME}:latest,${IMAGE_NAME}:sha-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      # 6) 도커 빌드 & 푸시 (레포 루트 Dockerfile 사용)
      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.tag.outputs.TAGS }}
          build-args: |
            JAR_FILE=${{ env.ARTIFACT }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Prepare SSH
        run: |
          install -m 600 -D /dev/null ~/.ssh/id_ci
          printf '%s\n' "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_ci
          printf '%s\n' "${{ secrets.EC2_HOST_KEY }}" >> ~/.ssh/known_hosts

      # 레포의 docker-compose.yml을 서버에 반영
      - name: Upload compose to server
        run: |
          scp -i ~/.ssh/id_ci ./docker-compose.yml deploy@${{ secrets.EC2_HOST }}:/srv/app/current/docker-compose.yml

      - name: Remote deploy
        env:
          GH_USER: ${{ github.actor }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ssh -T -i ~/.ssh/id_ci \
            GH_USER="$GH_USER" GH_TOKEN="$GH_TOKEN" \
            deploy@${{ secrets.EC2_HOST }} 'bash -s' <<'EOSSH'
          set -euo pipefail
          cd /srv/app/current
          # GHCR 로그인(토큰을 stdin으로 안전하게 전달)
          echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USER" --password-stdin
          docker compose pull app
          docker compose up -d --no-deps app
          docker image prune -f
          EOSSH